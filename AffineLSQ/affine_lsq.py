# -*- coding: utf-8 -*-
"""Affine_LSQ.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kL_n2grLkXRPod07-QUx1ls1G1gLwnz-
"""

#from google.colab import drive
#drive.mount('/content/drive')
#! pip install geopandas

#
#
import numpy as np
import pandas as pd
import geopandas as gpd

######################################################################
def SolveAffine( df ):
    #
    #  xp1 = a*x1 + b*y1  +    c        ___       ____    ____
    #  yp1 = ___    ____     _____     d*x1 + e*y1 + f
    #
    A = list()  ; L=list()
    for i,row in df.iterrows():
        #print( i,row )
        #print( row.col_px, row.row_px )
        A.append(  [ row.xp_mm, row.yp_mm, 1, 0 ,0, 0  ] )
        A.append( [    0, 0, 0, row.xp_mm, row.yp_mm, 1 ])
        L.append( [row.col_px ] )
        L.append( [row.row_px ] )
    A = np.matrix( np.array(A) )
    L = np.matrix( np.array(L) )

    np.set_printoptions(suppress=True) # don't use scientific notation
    #print( "=====A =====\n",  A )
    print( "===== L =====\n", L.T)
    #  least-square
    N = A.T*A
    n = A.T*L
    # solution  X  :   a,b,c,d,e,f
    X = N.I*n
    v = A*X-L  # residues
    return X,v

def InvAffine( abcdef ):
        a,b,c,d,e,f = abcdef
        ae_bd = 1./ (a*e - b*d)
        a_ =  e * ae_bd
        b_ = -b * ae_bd
        c_ =   -(c*e - b*f) *ae_bd
        d_ = -d * ae_bd
        e_ =  a * ae_bd
        f_ =   (c*d - a*f) *ae_bd
        return (a_,b_,c_,  d_,e_,f_)

################################################################

print( np.finfo(np.longdouble).precision  )
#FILE_CSV = r"/content/drive/MyDrive/Dev/62_affine.csv"
#FILE_CSV = r"/content/drive/MyDrive/Dev/62_affine.csv"
for FILE_CSV in ( "62_affine.csv", "63_affine.csv" ):
    print(f'@@@@@@@@@@@@@@ Reading CSV "{FILE_CSV}"...@@@@@@@@@@@@@@@@@@@@@@@')
    df = pd.read_csv( FILE_CSV, delim_whitespace=False, header=None, 
            names=["Name","col_px", "row_px", "xp_mm", "yp_mm"])
    #df.info()
    #print( df )
    X,v = SolveAffine( df )

    print( '========Solution X a, b , c , d , e , f ==========')
    for i,x in enumerate(  ['a','b','c','d', 'e', 'f' ] ):
      print( f'Coefficient {x} : {float(X[i])} ' )

    print( '========Solution v (pixel) ==========')
    print ( np.around( np.reshape(v,(-1,2)), decimals=1 )  )

    print( '========Solution affine transformation ==========')
    AFF = np.array(X).flatten()
    print( f'xj_px     =   {AFF[0]:g}*xp_mm +  {AFF[1]:g}*yp_mm +  {AFF[2]:g} ' )
    print( f'yi_px     =   {AFF[3]:g}*xp_mm +  {AFF[4]:g}*yp_mm +  {AFF[5]:g} ' )
    print( '========Solution inverse affine transformation ==========')
    AFF_ = InvAffine( AFF )
    print( f'xp_mm     =   {AFF_[0]:g}*xj_px +  {AFF_[1]:g}*yi_px +  {AFF_[2]:g} ' )
    print( f'xp_mm     =   {AFF_[3]:g}*xj_px +  {AFF_[4]:g}*yi_px +  {AFF_[5]:g} ' )

    np.set_printoptions(precision=15,suppress=False)
    print('============TEST  xp,yp= +100.000 mm,+200.000 mm===============  ')
    K_mm2px = np.matrix( [     [ AFF[0], AFF[1], AFF[2]  ],
                               [ AFF[3], AFF[4],  AFF[5] ],   
                               [  0    ,   0   ,      1   ]   ] )     # K matrix
    print( '========== K_mm2px ==========\n', K_mm2px )
    # 2-D cartesian coordianate -> homogeneous coordinate system  
    Pnt_mm = np.matrix( [ [ +100.000, +200.000,  1 ] ] ).T
    print( '========== Pnt_mm ==========\n', Pnt_mm )
    Pnt_px = K_mm2px*Pnt_mm
    print( '========== Pnt_px ==========\n', Pnt_px )
    print( f'ANSWER :        column = {Pnt_px[0,0]:,.1f} pixel             row = {Pnt_px[1,0]:,.1f} pixel ')
    #        how about reverse ......... column = 14,222.7 pixel             row = 5,762.1 pixel 
    #     --->   xp ,yp  ?
    K_px2mm = K_mm2px.I
    print( '========== K_px2mm ==========\n', K_px2mm )
